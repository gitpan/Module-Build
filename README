NAME
    Module::Build - Build and install Perl modules

SYNOPSIS
    Standard process for building & installing modules:

       perl Build.PL
       ./Build
       ./Build test
       ./Build install

    Or, if you're on a platform (like DOS or Windows) that doesn't like the
    "./" notation, you can do this:

       perl Build.PL
       perl Build
       perl Build test
       perl Build install

DESCRIPTION
    "Module::Build" is a system for building, testing, and installing Perl
    modules. It is meant to be a replacement for "ExtUtils::MakeMaker".
    Developers may alter the behavior of the module through subclassing in a
    much more straightforward way than with "MakeMaker". It also does not
    require a "make" on your system - most of the "Module::Build" code is
    pure-perl and written in a very cross-platform way. In fact, you don't
    even need a shell, so even platforms like MacOS (traditional) can use it
    fairly easily. Its only prerequisites are modules that are included with
    perl 5.6.0, and it works fine on perl 5.005 if you can install a few
    additional modules.

    See the MOTIVATIONS manpage for more comparisons between
    "ExtUtils::MakeMaker" and "Module::Build".

    To install "Module::Build", and any other module that uses
    "Module::Build" for its installation process, do the following:

      perl Build.PL       # 'Build.PL' script creates the 'Build' script
      ./Build             # Need ./ to ensure we're using this "Build" script
      ./Build test        # and not another one that happens to be in the PATH
      ./Build install

    This illustrates initial configuration and the running of three
    'actions'. In this case the actions run are 'build' (the default
    action), 'test', and 'install'. Actions defined so far include:

      build                          fakeinstall   
      clean                          help          
      code                           install       
      diff                           manifest      
      dist                           ppd           
      distcheck                      ppmdist       
      distclean                      realclean     
      distdir                        skipcheck     
      distmeta                       test          
      distsign                       testdb        
      disttest                       versioninstall
      docs

    You can run the 'help' action for a complete list of actions.

    When creating a "Build.PL" script for a module, something like the
    following code will typically be used:

      use Module::Build;
      my $build = Module::Build->new
        (
         module_name => 'Foo::Bar',
         license => 'perl',
         requires => {
                      'perl'           => '5.6.1',
                      'Some::Module'   => '1.23',
                      'Other::Module'  => '>= 1.2, != 1.5, < 2.0',
                     },
        );
      $build->create_build_script;

    A simple module could get away with something as short as this for its
    "Build.PL" script:

      use Module::Build;
      Module::Build->new(
         module_name => 'Foo::Bar',
         license => 'perl',
      )->create_build_script;

    The model used by "Module::Build" is a lot like the "MakeMaker"
    metaphor, with the following correspondences:

       In Module::Build                 In ExtUtils::MakeMaker
      ---------------------------      ------------------------
       Build.PL (initial script)        Makefile.PL (initial script)
       Build (a short perl script)      Makefile (a long Makefile)
       _build/ (saved state info)       various config text in the Makefile

    Any customization can be done simply by subclassing "Module::Build" and
    adding a method called (for example) "ACTION_test", overriding the
    default 'test' action. You could also add a method called
    "ACTION_whatever", and then you could perform the action "Build
    whatever".

    For information on providing backward compatibility with
    "ExtUtils::MakeMaker", see the Module::Build::Compat manpage and
    http://www.makemaker.org/wiki/index.cgi?ModuleBuildConversionGuide.

METHODS
    I list here some of the most important methods in "Module::Build".
    Normally you won't need to deal with these methods unless you want to
    subclass "Module::Build". But since one of the reasons I created this
    module in the first place was so that subclassing is possible (and
    easy), I will certainly write more docs as the interface stabilizes.

    new()
        Creates a new Module::Build object. Arguments to the new() method
        are listed below. Most arguments are optional, but you must provide
        either the "module_name" argument, or "dist_name" and one of
        "dist_version" or "dist_version_from". In other words, you must
        provide enough information to determine both a distribution name and
        version.

        module_name
            The "module_name" is a shortcut for setting default values of
            "dist_name" and "dist_version_from", reflecting the fact that
            the majority of CPAN distributions are centered around one
            "main" module. For instance, if you set "module_name" to
            "Foo::Bar", then "dist_name" will default to "Foo-Bar" and
            "dist_version_from" will default to "lib/Foo/Bar.pm".
            "dist_version_from" will in turn be used to set "dist_version".

            Setting "module_name" won't override a "dist_*" parameter you
            specify explicitly.

        dist_name
            Specifies the name for this distribution. Most authors won't
            need to set this directly, they can use "module_name" to set
            "dist_name" to a reasonable default. However, some agglomerative
            distributions like "libwww-perl" or "bioperl" have names that
            don't correspond directly to a module name, so "dist_name" can
            be set independently.

        dist_version
            Specifies a version number for the distribution. See
            "module_name" or "dist_version_from" for ways to have this set
            automatically from a "$VERSION" variable in a module. One way or
            another, a version number needs to be set.

        dist_version_from
            Specifies a file to look for the distribution version in. Most
            authors won't need to set this directly, they can use
            "module_name" to set it to a reasonable default.

            The version is extracted from the specified file according to
            the same rules as "ExtUtils::MakeMaker" and "CPAN.pm". It
            involves finding the first line that matches the regular
            expression

               /([\$*])(([\w\:\']*)\bVERSION)\b.*\=/

            , eval()-ing that line, then checking the value of the
            "$VERSION" variable. Quite ugly, really, but all the modules on
            CPAN depend on this process, so there's no real opportunity to
            change to something better.

        license
            Specifies the licensing terms of your distribution. Valid
            options include:

            perl
                The distribution may be copied and redistributed under the
                same terms as perl itself (this is by far the most common
                licensing option for modules on CPAN). This is a dual
                license, in which the user may choose between either the GPL
                or the Artistic license.

            gpl The distribution is distributed under the terms of the Gnu
                General Public License
                (http://www.opensource.org/licenses/gpl-license.php).

            lgpl
                The distribution is distributed under the terms of the Gnu
                Lesser General Public License
                (http://www.opensource.org/licenses/lgpl-license.php).

            artistic
                The distribution is licensed under the Artistic License, as
                specified by the Artistic file in the standard perl
                distribution.

            bsd The distribution is licensed under the BSD License
                (http://www.opensource.org/licenses/bsd-license.php).

            open_source
                The distribution is licensed under some other Open Source
                Initiative-approved license listed at
                http://www.opensource.org/licenses/ .

            unrestricted
                The distribution is licensed under a license that is not
                approved by www.opensource.org but that allows distribution
                without restrictions.

            restrictive
                The distribution may not be redistributed without special
                permission from the author and/or copyright holder.

            Note that you must still include the terms of your license in
            your documentation - this field only lets automated tools figure
            out your licensing restrictions. Humans still need something to
            read.

            It is a fatal error to use a license other than the ones
            mentioned above. This is not because I wish to impose licensing
            terms on you - please let me know if you would like another
            license option to be added to the list. You may also use a
            license type of "unknown" if you don't wish to specify your
            terms (but this is usually not a good idea for you to do!).

            I just started out with a small set of licenses to keep things
            simple, figuring I'd let people with actual working knowledge in
            this area tell me what to do. So if that's you, drop me a line.

        requires
            An optional "requires" argument specifies any module
            prerequisites that the current module depends on. The
            prerequisites are given in a hash reference, where the keys are
            the module names and the values are version specifiers:

             requires => {Foo::Module => '2.4',
                          Bar::Module => 0,
                          Ken::Module => '>= 1.2, != 1.5, < 2.0',
                          perl => '5.6.0'},

            These four version specifiers have different effects. The value
            "'2.4'" means that at least version 2.4 of "Foo::Module" must be
            installed. The value "0" means that any version of "Bar::Module"
            is acceptable, even if "Bar::Module" doesn't define a version.
            The more verbose value "'>= 1.2, != 1.5, < 2.0'" means that
            "Ken::Module"'s version must be at least 1.2, less than 2.0, and
            not equal to 1.5. The list of criteria is separated by commas,
            and all criteria must be satisfied.

            A special "perl" entry lets you specify the versions of the Perl
            interpreter that are supported by your module. The same version
            dependency-checking semantics are available, except that we also
            understand perl's new double-dotted version numbers.

            One note: currently "Module::Build" doesn't actually *require*
            the user to have dependencies installed, it just strongly urges.
            In the future we may require it. There's now a "recommends"
            section for things that aren't absolutely required.

            Automated tools like CPAN.pm should refuse to install a module
            if one of its dependencies isn't satisfied, unless a "force"
            command is given by the user. If the tools are helpful, they
            should also offer to install the dependencies.

            A sysnonym for "requires" is "prereq", to help succour people
            transitioning from "ExtUtils::MakeMaker". The "requires" term is
            preferred, but the "prereq" term will remain valid in future
            distributions.

        recommends
            This is just like the "requires" argument, except that modules
            listed in this section aren't essential, just a good idea. We'll
            just print a friendly warning if one of these modules aren't
            found, but we'll continue running.

            If a module is recommended but not required, all tests should
            still pass if the module isn't installed. This may mean that
            some tests will be skipped if recommended dependencies aren't
            present.

            Automated tools like CPAN.pm should inform the user when
            recommended modules aren't installed, and it should offer to
            install them if it wants to be helpful.

        build_requires
            Modules listed in this section are necessary to build and
            install the given module, but are not necessary for regular
            usage of it. This is actually an important distinction - it
            allows for tighter control over the body of installed modules,
            and facilitates correct dependency checking on binary/packaged
            distributions of the module.

        conflicts
            Modules listed in this section conflict in some serious way with
            the given module. "Module::Build" (or some higher-level tool)
            will refuse to install the given module if the given
            module/version is also installed.

        create_makefile_pl
            This parameter lets you use Module::Build::Compat during the
            "distdir" (or "dist") action to automatically create a
            Makefile.PL for compatibility with ExtUtils::MakeMaker. The
            parameter's value should be one of the styles named in the
            Module::Build::Compat documentation.

        create_readme
            This parameter tells Module::Build to automatically create a
            README file at the top level of your distribution. Currently it
            will simply use "Pod::Text" on the file indicated by
            "dist_version_from" and put the result in the README file. This
            is by no means the only recommended style for writing a README,
            but it seems to be one common one used on the CPAN.

        c_source
            An optional "c_source" argument specifies a directory which
            contains C source files that the rest of the build may depend
            on. Any ".c" files in the directory will be compiled to object
            files. The directory will be added to the search path during the
            compilation and linking phases of any C or XS files.

        pm_files
            An optional parameter specifying the set of ".pm" files in this
            distribution, specified as a hash reference whose keys are the
            files' locations in the distributions, and whose values are
            their logical locations based on their package name, i.e. where
            they would be found in a "normal" Module::Build-style
            distribution. This parameter is mainly intended to support
            alternative layouts of files.

            For instance, if you have an old-style MakeMaker distribution
            for a module called "Foo::Bar" and a Bar.pm file at the top
            level of the distribution, you could specify your layout in your
            "Build.PL" like this:

             my $build = Module::Build->new
               ( module_name => 'Foo::Bar',
                 ...
                 pm_files => { 'Bar.pm' => 'lib/Foo/Bar.pm' },
               );

            Note that the values should include "lib/", because this is
            where they would be found in a "normal" Module::Build-style
            distribution.

            Note also that the path specifications are *always* given in
            Unix-like format, not in the style of the local system.

        pod_files
            Just like "pm_files", but used for specifying the set of ".pod"
            files in your distribution.

        xs_files
            Just like "pm_files", but used for specifying the set of ".xs"
            files in your distribution.

        PL_files
            An optional parameter specifying a set of ".PL" files in your
            distribution. These will be run as Perl scripts prior to
            processing the rest of the files in your distribution. They are
            usually used as templates for creating other files dynamically,
            so that a file like "lib/Foo/Bar.pm.PL" might create the file
            "lib/Foo/Bar.pm".

            The files are specified with the ".PL" files as hash keys, and
            the file(s) they generate as hash values, like so:

             my $build = Module::Build->new
               ( module_name => 'Foo::Bar',
                 ...
                 PL_files => { 'lib/Bar.pm.PL' => 'lib/Bar.pm',
                               'lib/Foo.PL' => [ 'lib/Foo1.pm', 'lib/Foo2.pm' ],
                             },
               );

            Note that the path specifications are *always* given in
            Unix-like format, not in the style of the local system.

        script_files
            An optional parameter specifying a set of files that should be
            installed as executable perl scripts when the module is
            installed. May be given as an array reference of the files, or
            as a hash reference whose keys are the files (and whose values
            will currently be ignored).

            The default is to install no script files - in other words,
            there is no default location where Module::Build will look for
            script files to install.

            For backward compatibility, you may use the parameter "scripts"
            instead of "script_files". Please consider this usage
            deprecated, though it will continue to exist for several version
            releases.

        test_files
            An optional parameter specifying a set of files that should be
            used as "Test::Harness"-style regression tests to be run during
            the "test" action. May be given as an array reference of the
            files, or as a hash reference whose keys are the files (and
            whose values will currently be ignored). If the argument is
            given as a single string (not in an array reference), that
            string will be treated as a "glob()" pattern specifying the
            files to use.

            The default is to look for a test.pl script in the top-level
            directory of the distribution, and any files matching the glob
            pattern "*.t" in the t/ subdirectory. If the
            "recursive_test_files" property is true, then the "t/" directory
            will be scanned recursively for "*.t" files.

        autosplit
            An optional "autosplit" argument specifies a file which should
            be run through the "Autosplit::autosplit()" function. In general
            I don't consider this a great idea, because it's not always
            clear that autosplitting achieves its intended performance
            benefits. It may even harm performance in environments like
            mod_perl, where as much as possible of a module's code should be
            loaded during startup.

        dynamic_config
            A boolean flag indicating whether the Build.PL file must be
            executed, or whether this module can be built, tested and
            installed solely from consulting its metadata file. The default
            value is 0, reflecting the fact that "most" of the modules on
            CPAN just need to be copied from one place to another. The main
            reason to set this to a true value is that your module performs
            some dynamic configuration as part of its build/install process.

            Currently "Module::Build" doesn't actually do anything with this
            flag - it's probably going to be up to tools like "CPAN.pm" to
            do something useful with it. It can potentially bring lots of
            security, packaging, and convenience improvements.

        add_to_cleanup
            An array reference of files to be cleaned up when the "clean"
            action is performed. See also the add_to_cleanup() method.

        sign
            If a true value is specified for this parameter,
            "Module::Signature" will be used (via the 'distsign' action) to
            create a SIGNATURE file for your distribution during the
            'distdir' action, and to add the SIGNATURE file to the MANIFEST
            (therefore, don't add it yourself).

            The default value is false. In the future, the default may
            change to true if you have "Module::Signature" installed on your
            system.

        extra_compiler_flags
        extra_linker_flags
            These parameters can contain array references (or strings, in
            which case they will be split into arrays) to pass through to
            the compiler and linker phases when compiling/linking C code.
            For example, to tell the compiler that your code is C++, you
            might do:

             my build = Module::Build->new(
                 module_name          => 'Spangly',
                 extra_compiler_flags => ['-x', 'c++'],
             );

            To link your XS code against glib you might write something
            like:

             my build = Module::Build->new(
                 module_name          => 'Spangly',
                 dynamic_config       => 1,
                 extra_compiler_flags => scalar `glib-config --cflags`,
                 extra_linker_flags   => scalar `glib-config --libs`,
             );

        dist_author
            This should be something like "John Doe <jdoe@example.com>", or
            if there are multiple authors, an anonymous array of strings may
            be specified. This is used when generating metadata for META.yml
            and PPD files. If this is not specified, then "Module::Build"
            looks at the module from which it gets the distribution's
            version. If it finds a POD section marked "=head1 AUTHOR", then
            it uses the contents of this section.

        dist_abstract
            This should be a short description of the distribution. This is
            used when generating metadata for META.yml and PPD files. If it
            is not given then "Module::Build" looks in the POD of the module
            from which it gets the distribution's version. It looks for the
            first line matching "$package\s-\s(.+)", and uses the captured
            text as the abstract.

    subclass()
        This creates a new "Module::Build" subclass on the fly, as described
        in the the SUBCLASSING manpage section. The caller must provide
        either a "class" or "code" parameter, or both. The "class" parameter
        indicates the name to use for the new subclass, and defaults to
        "MyModuleBuilder". The "code" parameter specifies Perl code to use
        as the body of the subclass.

    create_build_script()
        Creates an executable script called "Build" in the current directory
        that will be used to execute further user actions. This script is
        roughly analogous (in function, not in form) to the Makefile created
        by "ExtUtils::MakeMaker". This method also creates some temporary
        data in a directory called "_build/". Both of these will be removed
        when the "realclean" action is performed.

    add_to_cleanup(@files)
        You may call "$self->add_to_cleanup(@files)" to tell "Module::Build"
        that certain files should be removed when the user performs the
        "Build clean" action. I decided to provide a dynamic method, rather
        than just use a static list of files, because these static lists can
        get difficult to manage. I usually prefer to keep the responsibility
        for registering temporary files close to the code that creates them.

    resume()
        You'll probably never call this method directly, it's only called
        from the auto-generated "Build" script. The "new()" method is only
        called once, when the user runs "perl Build.PL". Thereafter, when
        the user runs "Build test" or another action, the "Module::Build"
        object is created using the "resume()" method to reinstantiate with
        the settings given earlier to "new()".

    current()
        This method returns a reasonable faxsimile of the
        currently-executing "Module::Build" object representing the current
        build. You can use this object to query its "notes()" method,
        inquire about installed modules, and so on. This is a great way to
        share information between different parts of your building process.
        For instance, you can ask the user a question during "perl
        Build.PL", then use their answer during a regression test:

         # In Build.PL:
         my $color = $build->prompt("What is your favorite color?");
         $build->notes(color => $color);
 
         # In t/colortest.t:
         use Module::Build;
         my $build = Module::Build->current;
         my $color = $build->notes('color');
         ...

        The way the "current()" method is currently implemented, there may
        be slight differences between the "$build" object in Build.PL and
        the one in "t/colortest.t". It is our goal to minimize these
        differences in future releases of Module::Build, so please report
        any anomalies you find.

    notes()
    notes($key)
    notes($key => $value)
        The "notes()" value allows you to store your own persistent
        information about the build, and to share that information among
        different entities involved in the build. See the example in the
        "current()" method.

        The "notes()" method is essentally a glorified hash access. With no
        arguments, "notes()" returns a reference to the entire hash of
        notes. With one argument, "notes($key)" returns the value associated
        with the given key. With two arguments, "notes($key, $value)" sets
        the value associated with the given key to "$value".

    config()
        Returns a hash reference containing the "Config.pm" hash, including
        any changes the author or user has specified. This is a reference to
        the actual internal hash we use, so you probably shouldn't modify
        stuff there.

    dispatch($action, %args)
        This method is also called from the auto-generated "Build" script.
        It parses the command-line arguments into an action and an argument
        list, then calls the appropriate routine to handle the action.
        Currently (though this may change), an action "foo" will invoke the
        "ACTION_foo" method. All arguments (including everything mentioned
        in the ACTIONS manpage below) are contained in the "$self->{args}"
        hash reference.

    os_type()
        If you're subclassing Module::Build and some code needs to alter its
        behavior based on the current platform, you may only need to know
        whether you're running on Windows, Unix, MacOS, VMS, etc. and not
        the fine-grained value of Perl's "$^O" variable. The "os_type()"
        method will return a string like "Windows", "Unix", "MacOS", "VMS",
        or whatever is appropriate. If you're running on an unknown
        platform, it will return "undef" - there shouldn't be many unknown
        platforms though.

    prereq_failures()
        Returns a data structure containing information about any failed
        prerequisites (of any of the types described above), or "undef" if
        all prerequisites are met.

        The data structure returned is a hash reference. The top level keys
        are the type of prerequisite failed, one of "requires",
        "build_requires", "conflicts", or "recommends". The associated
        values are hash references whose keys are the names of required (or
        conflicting) modules. The associated values of those are hash
        references indicating some information about the failure. For
        example:

         {
          have => '0.42',
          need => '0.59',
          message => 'Version 0.42 is installed, but we need version 0.59',
         }

        or

         {
          have => '<none>',
          need => '0.59',
          message => 'Prerequisite Foo isn't installed',
         }

        This hash has the same structure as the hash returned by the
        "check_installed_status()" method, except that in the case of
        "conflicts" dependencies we change the "need" key to "conflicts" and
        construct a proper message.

        Examples:

          # Check a required dependency on Foo::Bar
          if ( $m->prereq_failures->{requires}{Foo::Bar} ) { ...

          # Check whether there were any failures
          if ( $m->prereq_failures ) { ...
  
          # Show messages for all failures
          my $failures = $m->prereq_failures;
          while (my ($type, $list) = each %$failures) {
            while (my ($name, $hash) = each %$list) {
              print "Failure for $name: $hash->{message}\n";
            }
          }

    requires()
    build_requires()
    recommends()
    conflicts()
        Each of these methods returns a hash reference indicating the
        prerequisites that were passed to the "new()" method.

    check_installed_status($module, $version)
        This method returns a hash reference indicating whether a version
        dependency on a certain module is satisfied. The "$module" argument
        is given as a string like ""Data::Dumper"" or ""perl"", and the
        "$version" argument can take any of the forms described in the
        requires manpage above. This allows very fine-grained version
        checking.

        The returned hash reference has the following structure:

         {
          ok => $whether_the_dependency_is_satisfied,
          have => $version_already_installed,
          need => $version_requested, # Same as incoming $version argument
          message => $informative_error_message,
         }

        If no version of "$module" is currently installed, the "have" value
        will be the string ""<none>"". Otherwise the "have" value will
        simply be the version of the installed module. Note that this means
        that if "$module" is installed but doesn't define a version number,
        the "have" value will be "undef" - this is why we don't use "undef"
        for the case when "$module" isn't installed at all.

        This method may be called either as an object method
        ("$build->check_installed_status($module, $version)") or as a class
        method ("Module::Build->check_installed_status($module, $version)").

    check_installed_version($module, $version)
        Like "check_installed_status()", but simply returns true or false
        depending on whether module "$module" statisfies the dependency
        "$version".

        If the check succeeds, the return value is the actual version of
        "$module" installed on the system. This allows you to do the
        following:

         my $installed = $m->check_installed_version('DBI', '1.15');
         if ($installed) {
           print "Congratulations, version $installed of DBI is installed.\n";
         } else {
           die "Sorry, you must install DBI.\n";
         }

        If the check fails, we return false and set "$@" to an informative
        error message.

        If "$version" is any nontrue value (notably zero) and any version of
        "$module" is installed, we return true. In this case, if "$module"
        doesn't define a version, or if its version is zero, we return the
        special value "0 but true", which is numerically zero, but logically
        true.

        In general you might prefer to use "check_installed_status" if you
        need detailed information, or this method if you just need a yes/no
        answer.

    prompt($message, $default)
        Asks the user a question and returns their response as a string. The
        first argument specifies the message to display to the user (for
        example, ""Where do you keep your money?""). The second argument,
        which is optional, specifies a default answer (for example,
        ""wallet""). The user will be asked the question once.

        If the current session doesn't seem to be interactive (i.e. if
        "STDIN" and "STDOUT" look like they're attached to files or
        something, not terminals), we'll just use the default without
        letting the user provide an answer.

        This method may be called as a class or object method.

    y_n($message, $default)
        Asks the user a yes/no question using "prompt()" and returns true or
        false accordingly. The user will be asked the question repeatedly
        until they give an answer that looks like "yes" or "no".

        The first argument specifies the message to display to the user (for
        example, ""Shall I invest your money for you?""), and the second
        argument specifies the default answer (for example, ""y"").

        Note that the default is specified as a string like ""y"" or ""n"",
        and the return value is a Perl boolean value like 1 or 0. I thought
        about this for a while and this seemed like the most useful way to
        do it.

        This method may be called as a class or object method.

    script_files()
        Returns a hash reference whose keys are the perl script files to be
        installed, if any. This corresponds to the "script_files" parameter
        to the "new()" method. With an optional argument, this parameter may
        be set dynamically.

        For backward compatibility, the "scripts()" method does exactly the
        same thing as "script_files()". "scripts()" is deprecated, but it
        will stay around for several versions to give people time to
        transition.

    copy_if_modified(%parameters)
        Takes the file in the "from" parameter and copies it to the file in
        the "to" parameter, or the directory in the "to_dir" parameter, if
        the file has changed since it was last copied (or if it doesn't
        exist in the new location). By default the entire directory
        structure of "from" will be copied into "to_dir"; an optional
        "flatten" parameter will copy into "to_dir" without doing so.

        Returns the path to the destination file, or "undef" if nothing
        needed to be copied.

        Any directories that need to be created in order to perform the
        copying will be automatically created.

    do_system($cmd, @args)
        This is a fairly simple wrapper around Perl's "system()" built-in
        command. Given a command and an array of optional arguments, this
        method will print the command to "STDOUT", and then execute it using
        Perl's "system()". It returns true or false to indicate success or
        failure (the opposite of how "system()" works, but more intuitive).

        Note that if you supply a single argument to "do_system()", it
        will/may be processed by the systems's shell, and any special
        characters will do their special things. If you supply multiple
        arguments, no shell will get involved and the command will be
        executed directly.

    have_c_compiler()
        Returns true if the current system seems to have a working C
        compiler. We currently determine this by attempting to compile a
        simple C source file and reporting whether the attempt was
        successful.

    base_dir()
        Returns a string containing the root-level directory of this build,
        i.e. where the "Build.PL" script and the "lib" directory can be
        found. This is usually the same as the current working directory,
        because the "Build" script will "chdir()" into this directory as
        soon as it begins execution.

    dist_name()
        Returns the name of the current distribution, as passed to the
        "new()" method in a "dist_name" or modified "module_name" parameter.

    dist_version()
        Returns the version of the current distribution, as determined by
        the "new()" method from a "dist_version", "dist_version_from", or
        "module_name" parameter.

    up_to_date($source_file, $derived_file)
    up_to_date(\@source_files, \@derived_files)
        This method can be used to compare a set of source files to a set of
        derived files. If any of the source files are newer than any of the
        derived files, it returns false. Additionally, if any of the derived
        files do not exist, it returns false. Otherwise it returns true.

        The arguments may be either a scalar or an array reference of file
        names.

    contains_pod($file)
        Returns true if the given file appears to contain POD documentation.
        Currently this checks whether the file has a line beginning with
        '=pod', '=head', or '=item', but the exact semantics may change in
        the future.

ACTIONS
    There are some general principles at work here. First, each task when
    building a module is called an "action". These actions are listed above;
    they correspond to the building, testing, installing, packaging, etc.
    tasks.

    Second, arguments are processed in a very systematic way. Arguments are
    always key=value pairs. They may be specified at "perl Build.PL" time
    (i.e. "perl Build.PL destdir=/my/secret/place"), in which case their
    values last for the lifetime of the "Build" script. They may also be
    specified when executing a particular action (i.e. "Build test
    verbose=1"), in which case their values last only for the lifetime of
    that command. Per-action command-line parameters take precedence over
    parameters specified at "perl Build.PL" time.

    The build process also relies heavily on the "Config.pm" module, and all
    the key=value pairs in "Config.pm" are available in

    "$self->{config}". If the user wishes to override any of the values in
    "Config.pm", she may specify them like so:

      perl Build.PL --config cc=gcc --config ld=gcc

    The following build actions are provided by default.

    help
        This action will simply print out a message that is meant to help
        you use the build process. It will show you a list of available
        build actions too.

        With an optional argument specifying an action name (e.g. "Build
        help test"), the 'help' action will show you any POD documentation
        it can find for that action.

    build
        If you run the "Build" script without any arguments, it runs the
        "build" action, which in turn runs the "code" and "docs" actions.

        This is analogous to the MakeMaker 'make all' target.

    code
        This action builds your codebase.

        By default it just creates a "blib/" directory and copies any ".pm"
        and ".pod" files from your "lib/" directory into the "blib/"
        directory. It also compiles any ".xs" files from "lib/" and places
        them in "blib/". Of course, you need a working C compiler (probably
        the same one that built perl itself) for the compilation to work
        properly.

        The "build" action also runs any ".PL" files in your lib/ directory.
        Typically these create other files, named the same but without the
        ".PL" ending. For example, a file lib/Foo/Bar.pm.PL could create the
        file lib/Foo/Bar.pm. The ".PL" files are processed first, so any
        ".pm" files (or other kinds that we deal with) will get copied
        correctly.

        If your ".PL" scripts don't create any files, or if they create
        files with unexpected names, or even if they create multiple files,
        you should tell us that so that we can clean up properly after these
        created files. Use the "PL_files" parameter to "new()":

         PL_files => { 'lib/Foo/Bar_pm.PL' => 'lib/Foo/Bar.pm',
                       'lib/something.PL'  => ['/lib/something', '/lib/else'],
                       'lib/funny.PL'      => [] }

        Note that in contrast to MakeMaker, the "build" action only
        (currently) handles ".pm", ".pod", ".PL", and ".xs" files. They must
        all be in the "lib/" directory, in the directory structure that they
        should have when installed. We also handle ".c" files that can be in
        the place of your choosing - see the "c_source" argument to "new()".

        The ".xs" support is currently in alpha. Please let me know whether
        it works for you.

    docs
        This will generate documentation (ie: Unix man pages) for any binary
        and library files under blib/ that contain POD. If there are no
        "bindoc" or "libdoc" installation targets defined (as will be the
        case on systems that don't support Unix manpages) this action does
        nothing.

    test
        This will use "Test::Harness" to run any regression tests and report
        their results. Tests can be defined in the standard places: a file
        called "test.pl" in the top-level directory, or several files ending
        with ".t" in a "t/" directory.

        If you want tests to be 'verbose', i.e. show details of test
        execution rather than just summary information, pass the argument
        "verbose=1".

        If you want to run tests under the perl debugger, pass the argument
        "debugger=1".

        In addition, if a file called "visual.pl" exists in the top-level
        directory, this file will be executed as a Perl script and its
        output will be shown to the user. This is a good place to put speed
        tests or other tests that don't use the "Test::Harness" format for
        output.

        To override the choice of tests to run, you may pass a "test_files"
        argument whose value is a whitespace-separated list of test scripts
        to run. This is especially useful in development, when you only want
        to run a single test to see whether you've squashed a certain bug
        yet:

         ./Build test --test_files t/something_failing.t

        You may also pass several "test_files" arguments separately:

         ./Build test --test_files t/one.t --test_files t/two.t

        or use a "glob()"-style pattern:

         ./Build test --test_files 't/01-*.t'

    testdb
        This is a synonym for the 'test' action with the "debugger=1"
        argument.

    clean
        This action will clean up any files that the build process may have
        created, including the "blib/" directory (but not including the
        "_build/" directory and the "Build" script itself).

    realclean
        This action is just like the "clean" action, but also removes the
        "_build" directory and the "Build" script. If you run the
        "realclean" action, you are essentially starting over, so you will
        have to re-create the "Build" script again.

    diff
        This action will compare the files about to be installed with their
        installed counterparts. For .pm and .pod files, a diff will be shown
        (this currently requires a 'diff' program to be in your PATH). For
        other files like compiled binary files, we simply report whether
        they differ.

        A "flags" parameter may be passed to the action, which will be
        passed to the 'diff' program. Consult your 'diff' documentation for
        the parameters it will accept - a good one is "-u":

         ./Build diff flags=-u

    install
        This action will use "ExtUtils::Install" to install the files from
        "blib/" into the system. See the How Installation Paths are
        Determined entry elsewhere in this document for details about how
        Module::Build determines where to install things, and how to
        influence this process.

        If you want the installation process to look around in "@INC" for
        other versions of the stuff you're installing and try to delete it,
        you can use the "uninst" parameter, which tells "ExtUtils::Install"
        to do so:

         Build install uninst=1

        This can be a good idea, as it helps prevent multiple versions of a
        module from being present on your system, which can be a confusing
        situation indeed.

    fakeinstall
        This is just like the "install" action, but it won't actually do
        anything, it will just report what it *would* have done if you had
        actually run the "install" action.

    versioninstall
        ** Note: since "only.pm" is so new, and since we just recently added
        support for it here too, this feature is to be considered
        experimental. **

        If you have the "only.pm" module installed on your system, you can
        use this action to install a module into the version-specific
        library trees. This means that you can have several versions of the
        same module installed and "use" a specific one like this:

         use only MyModule => 0.55;

        To override the default installation libraries in "only::config",
        specify the "versionlib" parameter when you run the "Build.PL"
        script:

         perl Build.PL versionlib=/my/version/place/

        To override which version the module is installed as, specify the
        "versionlib" parameter when you run the "Build.PL" script:

         perl Build.PL version=0.50

        See the "only.pm" documentation for more information on
        version-specific installs.

    manifest
        This is an action intended for use by module authors, not people
        installing modules. It will bring the MANIFEST up to date with the
        files currently present in the distribution. You may use a
        MANIFEST.SKIP file to exclude certain files or directories from
        inclusion in the MANIFEST. MANIFEST.SKIP should contain a bunch of
        regular expressions, one per line. If a file in the distribution
        directory matches any of the regular expressions, it won't be
        included in the MANIFEST.

        The following is a reasonable MANIFEST.SKIP starting point, you can
        add your own stuff to it:

           ^_build
           ^Build$
           ^blib
           ~$
           \.bak$
           ^MANIFEST\.SKIP$
           CVS

        See the the distcheck manpage and the skipcheck manpage actions if
        you want to find out what the "manifest" action would do, without
        actually doing anything.

    dist
        This action is helpful for module authors who want to package up
        their module for distribution through a medium like CPAN. It will
        create a tarball of the files listed in MANIFEST and compress the
        tarball using GZIP compression.

    ppmdist
        Generates a PPM binary distribution and a PPD description file. This
        action also invokes the 'ppd' action, so it can accept the same
        "codebase" argument described under that action.

    distsign
        Uses "Module::Signature" to create a SIGNATURE file for your
        distribution, and adds the SIGNATURE file to the distribution's
        MANIFEST.

    distmeta
        Creates the META.yml file for your distribution.

    distcheck
        Reports which files are in the build directory but not in the
        MANIFEST file, and vice versa. (See the manifest manpage for
        details)

    skipcheck
        Reports which files are skipped due to the entries in the
        MANIFEST.SKIP file (See the manifest manpage for details)

    distclean
        Performs the 'realclean' action and then the 'distcheck' action.

    distdir
        Creates a directory called "$(DISTNAME)-$(VERSION)" (if that
        directory already exists, it will be removed first). Then copies all
        the files listed in the MANIFEST file to that directory. This
        directory is what people will see when they download your
        distribution and unpack it.

        While performing the 'distdir' action, a file containing various
        bits of "metadata" will be created. The metadata includes the
        module's name, version, dependencies, license, and the
        "dynamic_config" flag. This file is created as META.yml in YAML
        format, so you must have the "YAML" module installed in order to
        create it. You should also ensure that the META.yml file is listed
        in your MANIFEST - if it's not, a warning will be issued.

    disttest
        Performs the 'distdir' action, then switches into that directory and
        runs a "perl Build.PL", followed by the 'build' and 'test' actions
        in that directory.

    ppd Build a PPD file for your distribution.

        This action takes an optional argument "codebase" which is used in
        the generated ppd file to specify the (usually relative) URL of the
        distribution. By default, this value is the distribution name
        without any path information.

        Example:

         perl Build ppd codebase="MSWin32-x86-multi-thread/Module-Build-0.21.tar.gz"

  How Installation Paths are Determined

    When you invoke Module::Build's "build" action, it needs to figure out
    where to install things. The nutshell version of how this works is that
    default installation locations are determined from Config.pm, and they
    may be overridden by using the "install_path" parameter. An
    "install_base" parameter lets you specify an alternative installation
    root like /home/foo, and a "destdir" lets you specify a temporary
    installation directory like /tmp/install in case you want to create
    bundled-up installable packages.

    Natively, Module::Build provides default installation locations for the
    following types of installable items:

    lib Usually pure-Perl module files ending in .pm.

    arch
        "Architecture-dependent" module files, usually produced by compiling
        XS, Inline, or similar code.

    script
        Programs written in pure Perl. In order to improve reuse, try to
        make these as small as possible - put the code into modules whenever
        possible.

    bin "Architecture-dependent" executable programs, i.e. compiled C code
        or something. Pretty rare to see this in a perl distribution, but it
        happens.

    libdoc
        Documentation for the stuff in "lib" and "arch". This is usually
        generated from the POD in .pm files. Under Unix, these are manual
        pages belonging to the 'man3' category.

    bindoc
        Documentation for the stuff in "script" and "bin". Usually generated
        from the POD in those files. Under Unix, these are manual pages
        belonging to the 'man1' category.

   installdirs

    The default destinations for these installable things come from entries
    in your system's "Config.pm". You can select from three different sets
    of default locations by setting the "installdirs" parameter as follows:

                              'installdirs' set to:
                       core          site                vendor
 
                  uses the following defaults from Config.pm:
 
     lib     => installprivlib  installsitelib      installvendorlib
     arch    => installarchlib  installsitearch     installvendorarch
     script  => installscript   installsitebin      installvendorbin
     bin     => installbin      installsitebin      installvendorbin
     libdoc  => installman3dir  installsiteman3dir  installvendorman3dir
     bindoc  => installman1dir  installsiteman1dir  installvendorman1dir

    The default value of "installdirs" is "site". If you're creating vendor
    distributions of module packages, you may want to do something like
    this:

     perl Build.PL installdirs=vendor

    or

     Build install installdirs=vendor

    If you're installing an updated version of a module that was included
    with perl itself (i.e. a "core module"), then you may set "installdirs"
    to "core" to overwrite the module in its present location.

    (Note that the 'script' line is different from MakeMaker - unfortunately
    there's no such thing as "installsitescript" or "installvendorscript"
    entry in "Config.pm", so we use the "installsitebin" and
    "installvendorbin" entries to at least get the general location right.
    In the future, if "Config.pm" adds some more appropriate entries, we'll
    start using those.)

   install_path

    Once the defaults have been set, you can override them. You can set
    individual entries by using the "install_path" parameter:

     my $m = Module::Build->new
      (...other options...,
       install_path => {lib  => '/foo/lib',
                        arch => '/foo/lib/arch'});

    On the command line, that would look like this:

     perl Build.PL --install_path lib=/foo/lib --install_path arch=/foo/lib/arch

    or this:

     Build install --install_path lib=/foo/lib --install_path arch=/foo/lib/arch

   install_base

    You can also set the whole bunch of installation paths by supplying the
    "install_base" parameter to point to a directory on your system. For
    instance, if you set "install_base" to "/home/ken" on a Linux system,
    you'll install as follows:

     lib     => /home/ken/lib
     arch    => /home/ken/lib/i386-linux
     script  => /home/ken/scripts
     bin     => /home/ken/bin
     libdoc  => /home/ken/man/man1
     bindoc  => /home/ken/man/man3

    Note that this is *different* from how MakeMaker's "PREFIX" parameter
    works. "PREFIX" tries to create a mini-replica of a "site"-style
    installation under the directory you specify, which is not always
    possible (and the results are not always pretty in this case).
    "install_base" just gives you a default layout under the directory you
    specify, which may have little to do with the "installdirs=site" layout.

    The exact layout under the directory you specify may vary by system - we
    try to do the "sensible" thing on each platform.

   destdir

    If you want to install everything into a temporary directory first (for
    instance, if you want to create a directory tree that a package manager
    like "rpm" or "dpkg" could create a package from), you can use the
    "destdir" parameter:

     perl Build.PL destdir=/tmp/foo

    or

     Build install destdir=/tmp/foo

    This will effectively install to "/tmp/foo/$sitelib",
    "/tmp/foo/$sitearch", and the like, except that it will use "File::Spec"
    to make the pathnames work correctly on whatever platform you're
    installing on.

AUTOMATION
    One advantage of Module::Build is that since it's implemented as Perl
    methods, you can invoke these methods directly if you want to install a
    module non-interactively. For instance, the following Perl script will
    invoke the entire build/install procedure:

     my $m = Module::Build->new(module_name => 'MyModule');
     $m->dispatch('build');
     $m->dispatch('test');
     $m->dispatch('install');

    If any of these steps encounters an error, it will throw a fatal
    exception.

    You can also pass arguments as part of the build process:

     my $m = Module::Build->new(module_name => 'MyModule');
     $m->dispatch('build');
     $m->dispatch('test', verbose => 1);
     $m->dispatch('install', sitelib => '/my/secret/place/');

    Building and installing modules in this way skips creating the "Build"
    script.

STRUCTURE
    Module::Build creates a class hierarchy conducive to customization. Here
    is the parent-child class hierarchy in classy ASCII art:

       /--------------------\
       |   Your::Parent     |  (If you subclass Module::Build)
       \--------------------/
                |
                |
       /--------------------\  (Doesn't define any functionality
       |   Module::Build    |   of its own - just figures out what
       \--------------------/   other modules to load.)
                |
                |
       /-----------------------------------\  (Some values of $^O may
       |   Module::Build::Platform::$^O    |   define specialized functionality.
       \-----------------------------------/   Otherwise it's ...::Default, a
                |                              pass-through class.)
                |
       /--------------------------\
       |   Module::Build::Base    |  (Most of the functionality of 
       \--------------------------/   Module::Build is defined here.)

SUBCLASSING
    Right now, there are two ways to subclass Module::Build. The first way
    is to create a regular module (in a ".pm" file) that inherits from
    Module::Build, and use that module's class instead of using
    Module::Build directly:

      ------ in Build.PL: ----------
      #!/usr/bin/perl
  
      use lib qw(/nonstandard/library/path);
      use My::Builder;  # Or whatever you want to call it
  
      my $m = My::Builder->new(module_name => 'Next::Big::Thing');
      $m->create_build_script;

    This is relatively straightforward, and is the best way to do things if
    your My::Builder class contains lots of code. The
    "create_build_script()" method will ensure that the current value of
    "@INC" (including the "/nonstandard/library/path") is propogated to the
    Build script, so that My::Builder can be found when running build
    actions.

    For very small additions, Module::Build provides a "subclass()" method
    that lets you subclass Module::Build more conveniently, without creating
    a separate file for your module:

      ------ in Build.PL: ----------
      #!/usr/bin/perl
  
      my $class = Module::Build->subclass
        (
         class => 'My::Builder',
         code => q{
          sub ACTION_foo {
            print "I'm fooing to death!\n";
          }
         },
        );
  
      my $m = $class->new(module_name => 'Module::Build');
      $m->create_build_script;

    Behind the scenes, this actually does create a ".pm" file, since the
    code you provide must persist after Build.PL is run if it is to be very
    useful.

    See also the documentation for the "subclass()" method.

MOTIVATIONS
    There are several reasons I wanted to start over, and not just fix what
    I didn't like about MakeMaker:

    *   I don't like the core idea of MakeMaker, namely that "make" should
        be involved in the build process. Here are my reasons:

        +   When a person is installing a Perl module, what can you assume
            about their environment? Can you assume they have "make"? No,
            but you can assume they have some version of Perl.

        +   When a person is writing a Perl module for intended
            distribution, can you assume that they know how to build a
            Makefile, so they can customize their build process? No, but you
            can assume they know Perl, and could customize that way.

        For years, these things have been a barrier to people getting the
        build/install process to do what they want.

    *   There are several architectural decisions in MakeMaker that make it
        very difficult to customize its behavior. For instance, when using
        MakeMaker you do "use MakeMaker", but the object created in
        "WriteMakefile()" is actually blessed into a package name that's
        created on the fly, so you can't simply subclass
        "ExtUtils::MakeMaker". There is a workaround "MY" package that lets
        you override certain MakeMaker methods, but only certain explicitly
        predefined (by MakeMaker) methods can be overridden. Also, the
        method of customization is very crude: you have to modify a string
        containing the Makefile text for the particular target. Since these
        strings aren't documented, and *can't* be documented (they take on
        different values depending on the platform, version of perl, version
        of MakeMaker, etc.), you have no guarantee that your modifications
        will work on someone else's machine or after an upgrade of MakeMaker
        or perl.

    *   It is risky to make major changes to MakeMaker, since it does so
        many things, is so important, and generally works. "Module::Build"
        is an entirely seperate package so that I can work on it all I want,
        without worrying about backward compatibility.

    *   Finally, Perl is said to be a language for system administration.
        Could it really be the case that Perl isn't up to the task of
        building and installing software? Even if that software is a bunch
        of stupid little ".pm" files that just need to be copied from one
        place to another? Are you getting riled up yet??

MIGRATION
    Note that if you want to provide both a Makefile.PL and a Build.PL for
    your distribution, you probably want to add the following to
    "WriteMakefile" in your Makefile.PL so that MakeMaker doesn't try to run
    your Build.PL as a normal .PL file:

     PL_FILES => {},

    You may also be interested in looking at the "Module::Build::Compat"
    module, which can automatically create various kinds of Makefile.PL
    compatibility layers.

TO DO
    The current method of relying on time stamps to determine whether a
    derived file is out of date isn't likely to scale well, since it
    requires tracing all dependencies backward, it runs into problems on
    NFS, and it's just generally flimsy. It would be better to use an MD5
    signature or the like, if available. See "cons" for an example.

    - append to perllocal.pod - write .packlist in appropriate location
    (needed for un-install)

AUTHOR
    Ken Williams, ken@mathforum.org

    Development questions, bug reports, and patches should be sent to the
    Module-Build mailing list at module-build-general@lists.sourceforge.net
    . Bug reports are also welcome at
    http://rt.cpan.org/NoAuth/Bugs.html?Dist=Module-Build .

    An anonymous CVS repository containing the latest development version is
    available; see http://sourceforge.net/cvs/?group_id=45731 for the
    details of how to access it.

SEE ALSO
    perl(1), Module::Build::Cookbook(3), ExtUtils::MakeMaker(3), YAML(3)

    http://www.dsmit.com/cons/

