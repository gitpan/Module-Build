NAME
    Module::Build - Build and install Perl modules

SYNOPSIS
    Standard process for building & installing modules:

       perl Build.PL
       ./Build
       ./Build test
       ./Build install

    Or, if you're on a platform (like DOS or Windows) that doesn't like the
    "./" notation, you can do this:

       perl Build.PL
       perl Build
       perl Build test
       perl Build install

DESCRIPTION
    `Module::Build' is a system for building, testing, and installing Perl
    modules. It is meant to be an alternative to `ExtUtils::MakeMaker'.
    Developers may alter the behavior of the module through subclassing in a
    much more straightforward way than with `MakeMaker'. It also does not
    require a `make' on your system - most of the `Module::Build' code is
    pure-perl and written in a very cross-platform way. In fact, you don't
    even need a shell, so even platforms like MacOS (traditional) can use it
    fairly easily. Its only prerequisites are modules that are included with
    perl 5.6.0, and it works fine on perl 5.005 if you can install a few
    additional modules.

    See "MOTIVATIONS" for more comparisons between `ExtUtils::MakeMaker' and
    `Module::Build'.

    To install `Module::Build', and any other module that uses
    `Module::Build' for its installation process, do the following:

      perl Build.PL       # 'Build.PL' script creates the 'Build' script
      ./Build             # Need ./ to ensure we're using this "Build" script
      ./Build test        # and not another one that happens to be in the PATH
      ./Build install

    This illustrates initial configuration and the running of three
    'actions'. In this case the actions run are 'build' (the default
    action), 'test', and 'install'. Other actions defined so far include:

    <action_list>

    You can run the 'help' action for a complete list of actions.

ACTIONS
    There are some general principles at work here. First, each task when
    building a module is called an "action". These actions are listed above;
    they correspond to the building, testing, installing, packaging, etc.
    tasks.

    Second, arguments are processed in a very systematic way. Arguments are
    always key=value pairs. They may be specified at `perl Build.PL' time
    (i.e. `perl Build.PL destdir=/my/secret/place'), in which case their
    values last for the lifetime of the `Build' script. They may also be
    specified when executing a particular action (i.e. `Build test
    verbose=1'), in which case their values last only for the lifetime of
    that command. Per-action command-line parameters take precedence over
    parameters specified at `perl Build.PL' time.

    The build process also relies heavily on the `Config.pm' module, and all
    the key=value pairs in `Config.pm' are available in

    `$self->{config}'. If the user wishes to override any of the values in
    `Config.pm', she may specify them like so:

      perl Build.PL --config cc=gcc --config ld=gcc

    The following build actions are provided by default.

    build
        If you run the `Build' script without any arguments, it runs the
        `build' action, which in turn runs the `code' and `docs' actions.

        This is analogous to the MakeMaker 'make all' target.

    clean
        This action will clean up any files that the build process may have
        created, including the `blib/' directory (but not including the
        `_build/' directory and the `Build' script itself).

    code
        This action builds your codebase.

        By default it just creates a `blib/' directory and copies any `.pm'
        and `.pod' files from your `lib/' directory into the `blib/'
        directory. It also compiles any `.xs' files from `lib/' and places
        them in `blib/'. Of course, you need a working C compiler (probably
        the same one that built perl itself) for the compilation to work
        properly.

        The `build' action also runs any `.PL' files in your lib/ directory.
        Typically these create other files, named the same but without the
        `.PL' ending. For example, a file lib/Foo/Bar.pm.PL could create the
        file lib/Foo/Bar.pm. The `.PL' files are processed first, so any
        `.pm' files (or other kinds that we deal with) will get copied
        correctly.

        If your `.PL' scripts don't create any files, or if they create
        files with unexpected names, or even if they create multiple files,
        you should tell us that so that we can clean up properly after these
        created files. Use the `PL_files' parameter to `new()':

         PL_files => { 'lib/Foo/Bar_pm.PL' => 'lib/Foo/Bar.pm',
                       'lib/something.PL'  => ['/lib/something', '/lib/else'],
                       'lib/funny.PL'      => [] }

        Note that in contrast to MakeMaker, the `build' action only
        (currently) handles `.pm', `.pod', `.PL', and `.xs' files. They must
        all be in the `lib/' directory, in the directory structure that they
        should have when installed. We also handle `.c' files that can be in
        the place of your choosing - see the `c_source' argument to `new()'.

        The `.xs' support is currently in alpha. Please let me know whether
        it works for you.

    config_data
        ...

    diff
        This action will compare the files about to be installed with their
        installed counterparts. For .pm and .pod files, a diff will be shown
        (this currently requires a 'diff' program to be in your PATH). For
        other files like compiled binary files, we simply report whether
        they differ.

        A `flags' parameter may be passed to the action, which will be
        passed to the 'diff' program. Consult your 'diff' documentation for
        the parameters it will accept - a good one is `-u':

         ./Build diff flags=-u

    dist
        This action is helpful for module authors who want to package up
        their module for source distribution through a medium like CPAN. It
        will create a tarball of the files listed in MANIFEST and compress
        the tarball using GZIP compression.

        By default, this action will use the external `tar' and `gzip'
        executables on Unix-like platforms, and the `Archive::Tar' module
        elsewhere. However, you can force it to use whatever executable you
        want by supplying an explicit `tar' (and optional `gzip') parameter:

         perl Build dist --tar C:\path\to\tar.exe --gzip C:\path\to\zip.exe

    distcheck
        Reports which files are in the build directory but not in the
        MANIFEST file, and vice versa. (See manifest for details)

    distclean
        Performs the 'realclean' action and then the 'distcheck' action.

    distdir
        Creates a directory called `$(DISTNAME)-$(VERSION)' (if that
        directory already exists, it will be removed first). Then copies all
        the files listed in the MANIFEST file to that directory. This
        directory is what people will see when they download your
        distribution and unpack it.

        While performing the 'distdir' action, a file containing various
        bits of "metadata" will be created. The metadata includes the
        module's name, version, dependencies, license, and the
        `dynamic_config' flag. This file is created as META.yml in YAML
        format, so you must have the `YAML' module installed in order to
        create it. You should also ensure that the META.yml file is listed
        in your MANIFEST - if it's not, a warning will be issued.

    distmeta
        Creates the META.yml file for your distribution.

    distsign
        Uses `Module::Signature' to create a SIGNATURE file for your
        distribution, and adds the SIGNATURE file to the distribution's
        MANIFEST.

    disttest
        Performs the 'distdir' action, then switches into that directory and
        runs a `perl Build.PL', followed by the 'build' and 'test' actions
        in that directory.

    docs
        This will generate documentation (ie: Unix man pages) for any binary
        and library files under blib/ that contain POD. If there are no
        `bindoc' or `libdoc' installation targets defined (as will be the
        case on systems that don't support Unix manpages) this action does
        nothing.

    fakeinstall
        This is just like the `install' action, but it won't actually do
        anything, it will just report what it *would* have done if you had
        actually run the `install' action.

    help
        This action will simply print out a message that is meant to help
        you use the build process. It will show you a list of available
        build actions too.

        With an optional argument specifying an action name (e.g. `Build
        help test'), the 'help' action will show you any POD documentation
        it can find for that action.

    install
        This action will use `ExtUtils::Install' to install the files from
        `blib/' into the system. See How Installation Paths are Determined
        for details about how Module::Build determines where to install
        things, and how to influence this process.

        If you want the installation process to look around in `@INC' for
        other versions of the stuff you're installing and try to delete it,
        you can use the `uninst' parameter, which tells `ExtUtils::Install'
        to do so:

         Build install uninst=1

        This can be a good idea, as it helps prevent multiple versions of a
        module from being present on your system, which can be a confusing
        situation indeed.

    manifest
        This is an action intended for use by module authors, not people
        installing modules. It will bring the MANIFEST up to date with the
        files currently present in the distribution. You may use a
        MANIFEST.SKIP file to exclude certain files or directories from
        inclusion in the MANIFEST. MANIFEST.SKIP should contain a bunch of
        regular expressions, one per line. If a file in the distribution
        directory matches any of the regular expressions, it won't be
        included in the MANIFEST.

        The following is a reasonable MANIFEST.SKIP starting point, you can
        add your own stuff to it:

           ^_build
           ^Build$
           ^blib
           ~$
           \.bak$
           ^MANIFEST\.SKIP$
           CVS

        See the distcheck and skipcheck actions if you want to find out what
        the `manifest' action would do, without actually doing anything.

    ppd Build a PPD file for your distribution.

        This action takes an optional argument `codebase' which is used in
        the generated ppd file to specify the (usually relative) URL of the
        distribution. By default, this value is the distribution name
        without any path information.

        Example:

         perl Build ppd codebase="MSWin32-x86-multi-thread/Module-Build-0.21.tar.gz"

    ppmdist
        Generates a PPM binary distribution and a PPD description file. This
        action also invokes the 'ppd' action, so it can accept the same
        `codebase' argument described under that action.

        This uses the same mechanism as the `dist' action to tar & zip its
        output, so you can supply `tar' and/or `gzip' parameters to affect
        the result.

    pure_install
        This action is identical to the `install' action. In the future,
        though, if `install' starts writing to the file file
        $(INSTALLARCHLIB)/perllocal.pod, `pure_install' won't, and that will
        be the only difference between them.

    realclean
        This action is just like the `clean' action, but also removes the
        `_build' directory and the `Build' script. If you run the
        `realclean' action, you are essentially starting over, so you will
        have to re-create the `Build' script again.

    skipcheck
        Reports which files are skipped due to the entries in the
        MANIFEST.SKIP file (See manifest for details)

    test
        This will use `Test::Harness' to run any regression tests and report
        their results. Tests can be defined in the standard places: a file
        called `test.pl' in the top-level directory, or several files ending
        with `.t' in a `t/' directory.

        If you want tests to be 'verbose', i.e. show details of test
        execution rather than just summary information, pass the argument
        `verbose=1'.

        If you want to run tests under the perl debugger, pass the argument
        `debugger=1'.

        In addition, if a file called `visual.pl' exists in the top-level
        directory, this file will be executed as a Perl script and its
        output will be shown to the user. This is a good place to put speed
        tests or other tests that don't use the `Test::Harness' format for
        output.

        To override the choice of tests to run, you may pass a `test_files'
        argument whose value is a whitespace-separated list of test scripts
        to run. This is especially useful in development, when you only want
        to run a single test to see whether you've squashed a certain bug
        yet:

         ./Build test --test_files t/something_failing.t

        You may also pass several `test_files' arguments separately:

         ./Build test --test_files t/one.t --test_files t/two.t

        or use a `glob()'-style pattern:

         ./Build test --test_files 't/01-*.t'

    testcover
        Runs the `test' action using `Devel::Cover', generating a
        code-coverage report showing which parts of the code were actually
        exercised during the tests.

        To pass options to `Devel::Cover', set the `$DEVEL_COVER_OPTIONS'
        environment variable:

          DEVEL_COVER_OPTIONS=-ignore,Build ./Build testcover

    testdb
        This is a synonym for the 'test' action with the `debugger=1'
        argument.

    testpod
        This checks all the files described in the `docs' action and
        produces `Test::Harness'-style output. If you are a module author,
        this is useful to run before creating a new release.

    versioninstall
        ** Note: since `only.pm' is so new, and since we just recently added
        support for it here too, this feature is to be considered
        experimental. **

        If you have the `only.pm' module installed on your system, you can
        use this action to install a module into the version-specific
        library trees. This means that you can have several versions of the
        same module installed and `use' a specific one like this:

         use only MyModule => 0.55;

        To override the default installation libraries in `only::config',
        specify the `versionlib' parameter when you run the `Build.PL'
        script:

         perl Build.PL versionlib=/my/version/place/

        To override which version the module is installed as, specify the
        `versionlib' parameter when you run the `Build.PL' script:

         perl Build.PL version=0.50

        See the `only.pm' documentation for more information on
        version-specific installs.

  Default Commandline Options (.modulebuildrc)

    When Module::Build starts up, it will look for a file,
    $ENV{HOME}/.modulebuildrc. If the file exists, the options specified
    there will be used as defaults, as if they were typed on the command
    line. The defaults can be overridden by specifying new values on the
    command line.

    The action name must come at the beginning of the line, followed by any
    amount of whitespace and then the options. Options are given the same as
    they would be on the commandline. They can be separated by any amount of
    whitespace, including newlines, as long there is whitespace at the
    beginning of each continued line. Anything following a hash mark (`#')
    is considered a comment, and is stripped before parsing. If more than
    one line begins with the same action name, those lines are merged into
    one set of options.

    Besides the regular actions, there are two special pseudo-actions: the
    key `*' (asterisk) denotes any global options that should be applied to
    all actions, and the key 'Build_PL' specifies options to be applied when
    you invoke `perl Build.PL'.

     *        verbose=1   # global options
     diff     flags=-u
     install  install_base=/home/ken
              --install_path html=/home/ken/docs/html

  How Installation Paths are Determined

    When you invoke Module::Build's `build' action, it needs to figure out
    where to install things. The nutshell version of how this works is that
    default installation locations are determined from Config.pm, and they
    may be overridden by using the `install_path' parameter. An
    `install_base' parameter lets you specify an alternative installation
    root like /home/foo, and a `destdir' lets you specify a temporary
    installation directory like /tmp/install in case you want to create
    bundled-up installable packages.

    Natively, Module::Build provides default installation locations for the
    following types of installable items:

    lib Usually pure-Perl module files ending in .pm.

    arch
        "Architecture-dependent" module files, usually produced by compiling
        XS, Inline, or similar code.

    script
        Programs written in pure Perl. In order to improve reuse, try to
        make these as small as possible - put the code into modules whenever
        possible.

    bin "Architecture-dependent" executable programs, i.e. compiled C code
        or something. Pretty rare to see this in a perl distribution, but it
        happens.

    libdoc
        Documentation for the stuff in `lib' and `arch'. This is usually
        generated from the POD in .pm files. Under Unix, these are manual
        pages belonging to the 'man3' category.

    bindoc
        Documentation for the stuff in `script' and `bin'. Usually generated
        from the POD in those files. Under Unix, these are manual pages
        belonging to the 'man1' category.

    Four other parameters let you control various aspects of how
    installation paths are determined:

    installdirs
        The default destinations for these installable things come from
        entries in your system's `Config.pm'. You can select from three
        different sets of default locations by setting the `installdirs'
        parameter as follows:

                                  'installdirs' set to:
                           core          site                vendor
 
                      uses the following defaults from Config.pm:
 
         lib     => installprivlib  installsitelib      installvendorlib
         arch    => installarchlib  installsitearch     installvendorarch
         script  => installscript   installsitebin      installvendorbin
         bin     => installbin      installsitebin      installvendorbin
         libdoc  => installman3dir  installsiteman3dir  installvendorman3dir
         bindoc  => installman1dir  installsiteman1dir  installvendorman1dir

        The default value of `installdirs' is "site". If you're creating
        vendor distributions of module packages, you may want to do
        something like this:

         perl Build.PL installdirs=vendor

        or

         Build install installdirs=vendor

        If you're installing an updated version of a module that was
        included with perl itself (i.e. a "core module"), then you may set
        `installdirs' to "core" to overwrite the module in its present
        location.

        (Note that the 'script' line is different from MakeMaker -
        unfortunately there's no such thing as "installsitescript" or
        "installvendorscript" entry in `Config.pm', so we use the
        "installsitebin" and "installvendorbin" entries to at least get the
        general location right. In the future, if `Config.pm' adds some more
        appropriate entries, we'll start using those.)

    install_path
        Once the defaults have been set, you can override them. You can set
        individual entries by using the `install_path' parameter:

         my $m = Module::Build->new
          (...other options...,
           install_path => {lib  => '/foo/lib',
                            arch => '/foo/lib/arch'});

        On the command line, that would look like this:

         perl Build.PL --install_path lib=/foo/lib --install_path arch=/foo/lib/arch

        or this:

         Build install --install_path lib=/foo/lib --install_path arch=/foo/lib/arch

    install_base
        You can also set the whole bunch of installation paths by supplying
        the `install_base' parameter to point to a directory on your system.
        For instance, if you set `install_base' to "/home/ken" on a Linux
        system, you'll install as follows:

         lib     => /home/ken/lib
         arch    => /home/ken/lib/i386-linux
         script  => /home/ken/scripts
         bin     => /home/ken/bin
         bindoc  => /home/ken/man/man1
         libdoc  => /home/ken/man/man3

        Note that this is *different* from how MakeMaker's `PREFIX'
        parameter works. Module::Build doesn't support MakeMaker's `PREFIX'
        option. See "Why PREFIX is not supported" for more details.
        `install_base' just gives you a default layout under the directory
        you specify, which may have little to do with the `installdirs=site'
        layout.

        The exact layout under the directory you specify may vary by system
        - we try to do the "sensible" thing on each platform.

    destdir
        If you want to install everything into a temporary directory first
        (for instance, if you want to create a directory tree that a package
        manager like `rpm' or `dpkg' could create a package from), you can
        use the `destdir' parameter:

         perl Build.PL destdir=/tmp/foo

        or

         Build install destdir=/tmp/foo

        This will effectively install to "/tmp/foo/$sitelib",
        "/tmp/foo/$sitearch", and the like, except that it will use
        `File::Spec' to make the pathnames work correctly on whatever
        platform you're installing on.

Alternatives to PREFIX
    Module::Build offers install_base as a simple, predictable, and
    user-configurable alternative to ExtUtils::MakeMaker's `PREFIX'. What's
    more, MakeMaker will soon accept `INSTALL_BASE' -- we strongly urge you
    to make the switch.

    Here's a quick comparison of the two when installing modules to your
    home directory on a unix box:

    MakeMaker [*]:

      % perl Makefile.PL PREFIX=/home/spurkis
      PERL5LIB=/home/spurkis/lib/perl5/5.8.5:/home/spurkis/lib/perl5/site_perl/5.8.5
      PATH=/home/spurkis/bin
      MANPATH=/home/spurkis/man

    Module::Build:

      % perl Build.PL install_base=/home/spurkis
      PERL5LIB=/home/spurkis/lib/perl5
      PATH=/home/spurkis/bin
      MANPATH=/home/spurkis/man

    [*] Note that MakeMaker's behaviour cannot be guaranteed in even this
    common scenario, and differs among different versions of MakeMaker.

    In short, using `install_base' is similar to the following MakeMaker
    usage:

      perl Makefile.PL PREFIX=/home/spurkis LIB=/home/spurkis/lib/perl5

    See How Installation Paths are Determined for details on other
    installation options available and how to configure them.

  Why PREFIX is not supported

    First, it is necessary to understand the original idea behind `PREFIX'.
    If, for example, the default installation locations for your machine are
    /usr/local/lib/perl5/5.8.5 for modules, /usr/local/bin for executables,
    /usr/local/man/man1 and /usr/local/man/man3 for manual pages, etc., then
    they all share the same "prefix" /usr/local. MakeMaker's `PREFIX'
    mechanism was intended as a way to change an existing prefix that
    happened to occur in all those paths - essentially a
    `s{/usr/local}{/foo/bar}' for each path.

    However, the real world is more complicated than that. The `PREFIX' idea
    is fundamentally broken when your machine doesn't jibe with `PREFIX''s
    worldview. A design decision was made not to support it in
    Module::Build, here's a summary of the reasons why:

    *   Many systems have Perl configs that make little sense with PREFIX.
        For example, OS X, where core modules go in
        /System/Library/Perl/..., user-installed modules go in
        /Library/Perl/..., and man pages go in /usr/share/man/.... The
        PREFIX is thus set to /. Install Foo::Bar on OS X with
        `PREFIX=/home/spurkis' and you get things like
        /home/spurkis/Library/Perl/5.8.1/Foo/Bar.pm and
        /home/spurkis/usr/share/man/man3/Foo::Bar.3pm. Not too pretty.

        The problem is not limited to Unix-like platforms, either - on
        Windows builds (e.g. ActiveState perl 5.8.0), we have user-installed
        modules going in C:\Perl\site\lib, user-installed executables going
        in C:\Perl\bin, and PREFIX=C:\Perl\site. The prefix just doesn't
        apply neatly to the executables.

    *   The PREFIX logic is too complicated and hard to predict for the
        user. It's hard to document what exactly is going to happen. You
        can't give a user simple instructions like "run perl Makefile.PL
        PREFIX=~ and then set PERL5LIB=~/lib/perl5".

    *   The results from PREFIX will change if your configuration of Perl
        changes (for example, if you upgrade Perl). This means your modules
        will end up in different places.

    *   The results from PREFIX can change with different releases of
        MakeMaker. The logic of PREFIX is subtle and it has been altered in
        the past (mostly to limit damage in the many "edge cases" when its
        behavior was undesirable).

    *   PREFIX imposes decisions made by the person who configured Perl onto
        the person installing a module. The person who configured Perl could
        have been you or it could have been some guy at Redhat.

  PREFIX will be supported

    The current maintainer of MakeMaker has offered to implement `PREFIX'
    pass-through support in Module::Build for backwards compatability only.
    You are still strongly recommended to use `install_base'.

MOTIVATIONS
    There are several reasons I wanted to start over, and not just fix what
    I didn't like about MakeMaker:

    *   I don't like the core idea of MakeMaker, namely that `make' should
        be involved in the build process. Here are my reasons:

        +   When a person is installing a Perl module, what can you assume
            about their environment? Can you assume they have `make'? No,
            but you can assume they have some version of Perl.

        +   When a person is writing a Perl module for intended
            distribution, can you assume that they know how to build a
            Makefile, so they can customize their build process? No, but you
            can assume they know Perl, and could customize that way.

        For years, these things have been a barrier to people getting the
        build/install process to do what they want.

    *   There are several architectural decisions in MakeMaker that make it
        very difficult to customize its behavior. For instance, when using
        MakeMaker you do `use ExtUtils::MakeMaker', but the object created
        in `WriteMakefile()' is actually blessed into a package name that's
        created on the fly, so you can't simply subclass
        `ExtUtils::MakeMaker'. There is a workaround `MY' package that lets
        you override certain MakeMaker methods, but only certain explicitly
        preselected (by MakeMaker) methods can be overridden. Also, the
        method of customization is very crude: you have to modify a string
        containing the Makefile text for the particular target. Since these
        strings aren't documented, and *can't* be documented (they take on
        different values depending on the platform, version of perl, version
        of MakeMaker, etc.), you have no guarantee that your modifications
        will work on someone else's machine or after an upgrade of MakeMaker
        or perl.

    *   It is risky to make major changes to MakeMaker, since it does so
        many things, is so important, and generally works. `Module::Build'
        is an entirely separate package so that I can work on it all I want,
        without worrying about backward compatibility.

    *   Finally, Perl is said to be a language for system administration.
        Could it really be the case that Perl isn't up to the task of
        building and installing software? Even if that software is a bunch
        of stupid little `.pm' files that just need to be copied from one
        place to another? My sense was that we could design a system to
        accomplish this in a flexible, extensible, and friendly manner. Or
        die trying.

TO DO
    The current method of relying on time stamps to determine whether a
    derived file is out of date isn't likely to scale well, since it
    requires tracing all dependencies backward, it runs into problems on
    NFS, and it's just generally flimsy. It would be better to use an MD5
    signature or the like, if available. See `cons' for an example.

    - append to perllocal.pod - write .packlist in appropriate location
    (needed for un-install) - add a 'plugin' functionality

AUTHOR
    Ken Williams, kwilliams@cpan.org

    Development questions, bug reports, and patches should be sent to the
    Module-Build mailing list at module-build-general@lists.sourceforge.net
    .

    Bug reports are also welcome at
    http://rt.cpan.org/NoAuth/Bugs.html?Dist=Module-Build .

    An anonymous CVS repository containing the latest development version is
    available; see http://sourceforge.net/cvs/?group_id=45731 for the
    details of how to access it.

COPYRIGHT
    Copyright (c) 2001-2005 Ken Williams. All rights reserved.

    This library is free software; you can redistribute it and/or modify it
    under the same terms as Perl itself.

SEE ALSO
    perl(1), Module::Build::Cookbook(3), Module::Build::Authoring(3),
    ExtUtils::MakeMaker(3), YAML(3)

    http://www.dsmit.com/cons/

